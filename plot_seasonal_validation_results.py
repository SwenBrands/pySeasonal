#!/usr/bin/env python

'''Verifies reanalysis data against AEMET station data, both brought into a comparable and harmonized format using 1. csv2nc.py and 2. get_neighbour.py prior to calling 3. validate.py (i.e. this script).
Author: Swen Brands, brandssf@ifca.unican.es
'''

#load packages
import numpy as np
import xarray as xr
import matplotlib.pyplot as plt
import cartopy
import cartopy.crs as ccrs
import cartopy.feature as cf
import os
import pandas as pd
import xskillscore as xs
from math import radians, cos, sin, asin, sqrt #needed to calculate haversine distance
home = os.getenv('HOME')
exec(open('functions_seasonal.py').read())
exec(open(home+'/datos/tareas/proyectos/pticlima/pyPTIclima/pySolar/functions_radiation.py').read())

#set input parameters
model_dataset = ['ecmwf51'] #list of model or reanalysis datasets: era5 or era5_land
ref_dataset = ['era5'] # #list of model or reference observational dataset paired with to <model_dataset>: aemet
rundir = home+'/datos/tareas/proyectos/pticlima/pyPTIclima/pySeasonal' #script directory, you should be there or point to this directory when running these scripts via python
dir_netcdf = home+'/datos/tareas/proyectos/pticlima/seasonal/results/validation' #path to outupt netcdf files produced with this script, containing an xarray dataset with all verification results
dir_figs = home+'/datos/tareas/proyectos/pticlima/seasonal/results/validation' #path to output figures file generated by this script
dir_maps = dir_figs+'/maps'
corr_outlier = 'no' #load the outlier-correted validation results; yes or no
detrending = 'yes' #yes or no, linear detrending of the gcm and obs time series prior to validation
file_years = [1981,2022] #start and end years indicated in the input file name
variables = ['t2m']
domain = 'medcof'
critval = 0.05

#scores = ['pearson_r','pearson_pval','pearson_pval_effn','spearman_r','spearman_pval','spearman_pval_effn'] #the scores to be plotted
#scores = ['pearson_pval','spearman_pval','crps_ensemble']
scores = ['pearson_r']

precision = 'float32' #precision of the variable in the output netCDF files
dpival = 300 #resultion of the output figure in dpi
figformat = 'pdf' #format of the output figures: pdf, png, etc.
colormap_ascend = 'Spectral_r' #ascendig colormap used for plotting: Spectral_r 
colormap_div = 'seismic' #diverging (zero-centered) colormap used for plotting: seismic
titlesize = 6

##EXECUTE ##############################################################
# #check consistency of input parameters
# if len(variables) < 2:
    # raise Exception('ERROR: At least two variables must be evaluated for this script to work! Check entries for <variables>.')

#create output directories ir they do not exist.
if os.path.isdir(dir_figs) != True:
    os.makedirs(dir_figs)
for vv in np.arange(len(variables)):
    if os.path.isdir(dir_figs+'/'+variables[vv]) != True:
        os.makedirs(dir_figs+'/'+variables[vv])  

#init global minimum and maximum values
minvals_map = np.empty((len(variables),len(model_dataset),len(scores)))
maxvals_map = np.empty((len(variables),len(model_dataset),len(scores)))
minvals_pcolor = np.empty((len(variables),len(model_dataset),len(scores)))
maxvals_pcolor = np.empty((len(variables),len(model_dataset),len(scores)))
for vv in np.arange(len(variables)):
    if os.path.isdir(dir_figs+'/'+variables[vv]+'/maps') != True:
        os.makedirs(dir_figs+'/'+variables[vv]+'/maps')
    for dd in range(len(model_dataset)):
        colormaps = [] #the colormap is the same for each dataset and only depends on the score so this is a list with a length equalling the length of <scores>
        #load netcdf files containing the verification results
        if model_dataset[dd] == 'ecmwf51':
            #verification_results_season_tp_ecmwf51_vs_era5_medcof_corroutlier_no_detrended_no_1981_2022.nc
            filename_results = 'verification_results_season_'+variables[vv]+'_'+model_dataset[dd]+'_vs_'+ref_dataset[dd]+'_'+domain+'_corroutlier_'+corr_outlier+'_detrended_'+detrending+'_'+str(file_years[0])+'_'+str(file_years[1])+'.nc'
        else:
            raise Exception('ERROR: unknown entry for <model_dataset> !')
        nc_results = xr.open_dataset(dir_netcdf+'/'+filename_results)
        halfres = np.abs(np.diff(nc_results.x.values))[0]/2 #needed to plot the pcolormesh
        
        #extract the min and max values for each score, <map> prefix points to values used for mapping at the grid-box scale and <pcolor> points to the values used in the pcolor figure
        for sc in np.arange(len(scores)):
            if scores[sc] in ('bias','relbias'):
                maxvals_map[vv,dd,sc] = np.abs(nc_results[scores[sc]]).max().values
                minvals_map[vv,dd,sc] = np.abs(nc_results[scores[sc]]).max().values*-1
                maxvals_pcolor[vv,dd,sc] = np.abs(nc_results[scores[sc]].mean(dim='x').mean(dim='y')).max().values #maximum of the seasonal areal mean values
                minvals_pcolor[vv,dd,sc] = np.abs(nc_results[scores[sc]].mean(dim='x').mean(dim='y')).max().values*-1 #minimum of the seasonal areal mean values
                colormaps.append(colormap_div)
            elif scores[sc] in ('mae','mape','rmse','crps_ensemble'):
                maxvals_map[vv,dd,sc] = nc_results[scores[sc]].max().values #global maximum for the specific model dataset and variable
                minvals_map[vv,dd,sc] = nc_results[scores[sc]].min().values #global minimum for the specific model dataset and variable
                maxvals_pcolor[vv,dd,sc] = nc_results[scores[sc]].mean(dim='x').mean(dim='y').max().values #maximum of the seasonal areal mean values
                minvals_pcolor[vv,dd,sc] = nc_results[scores[sc]].mean(dim='x').mean(dim='y').min().values #minimum of the seasonal areal mean values
                colormaps.append(colormap_ascend)
            elif scores[sc] in ('pearson_pval','pearson_pval_effn','spearman_pval','spearman_pval_effn'):
                if scores[sc] in ('pearson_pval','pearson_pval_effn'):
                    score_rho = 'pearson_r'
                elif scores[sc] in ('spearman_pval','spearman_pval_effn'):
                    score_rho = 'spearman_r'
                else:
                    raise Exception('ERROR: check entry in <scores[sc]> !')
                percent_sig, sig_arr = get_fraq_significance(nc_results[scores[sc]].values,nc_results[score_rho].values,critval)
                maxvals_pcolor[vv,dd,sc] = np.max(percent_sig)
                minvals_pcolor[vv,dd,sc] = 0
                colormaps.append(colormap_ascend)
            elif scores[sc] in ('pearson_r','spearman_r'):
                maxvals_map[vv,dd,sc] = nc_results[scores[sc]].max().values
                #minvals_map[vv,dd,sc] = nc_results[scores[sc]].min().values
                minvals_map[vv,dd,sc] = 0
                maxvals_pcolor[vv,dd,sc] = nc_results[scores[sc]].mean(dim='x').mean(dim='y').max().values #maximum of the seasonal areal mean values
                minvals_pcolor[vv,dd,sc] = nc_results[scores[sc]].mean(dim='x').mean(dim='y').min().values #minimum of the seasonal areal mean values
                colormaps.append(colormap_ascend)
                if scores[sc] in ('pearson_r'):
                    score_pval = 'pearson_pval'
                elif scores[sc] in ('spearman_r'):
                    score_pval = 'spearman_pval'
                else:
                    raise Exception('ERROR: check entry in <scores[sc]> !')
            else:
                raise Exception('ERROR: unknown value for <scores[sc]> !')

        ##close file
        nc_results.close()
    
##get global min and max values covering the range of all considered model / reanalysis datasets, currently does not take into account various GCM datasets, i.e. only works for len(model_dataset) == 1
minvals_pcolor = np.reshape(minvals_pcolor,(minvals_pcolor.shape[0]*minvals_pcolor.shape[1],minvals_pcolor.shape[2])).min(axis=0)
maxvals_pcolor = np.reshape(maxvals_pcolor,(maxvals_pcolor.shape[0]*maxvals_pcolor.shape[1],maxvals_pcolor.shape[2])).max(axis=0)
minvals_map = np.reshape(minvals_map,(minvals_map.shape[0]*minvals_map.shape[1],minvals_map.shape[2])).min(axis=0)
maxvals_map = np.reshape(maxvals_map,(maxvals_map.shape[0]*maxvals_map.shape[1],maxvals_map.shape[2])).max(axis=0)

#then plot the results with this min and max values
for vv in np.arange(len(variables)):
    for dd in range(len(model_dataset)):
        #load netcdf files containing the verification results
        if model_dataset[dd] == 'ecmwf51':
            #verification_results_season_tp_ecmwf51_vs_era5_medcof_corroutlier_no_detrended_no_1981_2022.nc
            filename_results = 'verification_results_season_'+variables[vv]+'_'+model_dataset[dd]+'_vs_'+ref_dataset[dd]+'_'+domain+'_corroutlier_'+corr_outlier+'_detrended_'+detrending+'_'+str(file_years[0])+'_'+str(file_years[1])+'.nc'
        else:
            raise Exception('ERROR: unknown entry for <model_dataset> !')
        nc_results = xr.open_dataset(dir_netcdf+'/'+filename_results)
        xx,yy = np.meshgrid(nc_results.x.values,nc_results.y.values)

        ##plot matrices of verification results for the distinct score (x-axis = seasons, y-axis = stations and save to <figformat>
        for sc in np.arange(len(scores)):
            print('INFO: plotting '+scores[sc]+'...')
            if os.path.isdir(dir_figs+'/'+variables[vv]+'/maps/'+scores[sc]) != True:
                os.makedirs(dir_figs+'/'+variables[vv]+'/maps/'+scores[sc])
            if scores[sc] in ('pearson_pval','pearson_pval_effn','spearman_pval','spearman_pval_effn'):
                #areal percentage of significant grid-box scale correlation coefficients is calculated and plotted
                savename = dir_figs+'/'+variables[vv]+'/pcolor_siggridboxes_'+variables[vv]+'_'+scores[sc]+'_'+domain+'_'+model_dataset[dd]+'_vs_'+ref_dataset[dd]+'_corr_outlier_'+corr_outlier+'_detrended_'+detrending+'_testlvl_'+str(round(critval*100))+'.'+figformat
                plotme, sig_arr = get_fraq_significance(nc_results[scores[sc]].values,nc_results[score_rho].values,critval)
                units_label = '%'
                name_label = 'areal fraction of sig. positive '+score_rho
            elif scores[sc] in ('pearson_r','spearman_r'):
                #areal percentage of significant grid-box scale correlation coefficients is calculated and plotted
                savename = dir_figs+'/'+variables[vv]+'/pcolor_arealmean_'+variables[vv]+'_'+scores[sc]+'_'+domain+'_'+model_dataset[dd]+'_vs_'+ref_dataset[dd]+'_corr_outlier_'+corr_outlier+'_detrended_'+detrending+'_testlvl_'+str(round(critval*100))+'.'+figformat
                pval = nc_results[score_pval].values
                rho = nc_results[scores[sc]].values
                plotme = nc_results[scores[sc]].mean(dim='y').mean(dim='x')
                units_label = 'dimensionless'
                name_label = scores[sc]
            elif scores[sc] in ('crps_ensemble'):
                #areal mean score is calculated and plotted
                savename = dir_figs+'/'+variables[vv]+'/pcolor_arealmean_'+variables[vv]+'_'+scores[sc]+'_'+domain+'_'+model_dataset[dd]+'_vs_'+ref_dataset[dd]+'_corr_outlier_'+corr_outlier+'_detrended_'+detrending+'.'+figformat
                plotme = nc_results[scores[sc]].mean(dim='y').mean(dim='x')
                units_label = nc_results[scores[sc]].units
                name_label = nc_results[scores[sc]].name
            else:
                raise Exception('ERROR: '+scores[sc]+' are currently not supported by plot_seasonal_validation_results.py !')
            #convert to xr dataArray and add metadata necessary for plotting
            plotme = xr.DataArray(plotme,coords=[np.arange(len(nc_results.season.values)),np.arange(len(nc_results.lead.values))],dims=['season', 'lead'], name=name_label)
            plotme.attrs['units'] = units_label
            plotme.attrs['season_label'] = nc_results.season.values
            plotme.attrs['lead_label'] = nc_results.lead.values
            plot_pcolormesh_seasonal(plotme,minvals_pcolor[sc],maxvals_pcolor[sc],savename,colormaps[sc],dpival)
            
            #produce a map for each variable, model dataset season and lead
            seasons = nc_results.season.values
            leads = nc_results.lead.values
            for sea in np.arange(len(seasons)):
                for ll in np.arange(len(leads)):
                    savename = dir_figs+'/'+variables[vv]+'/maps/'+scores[sc]+'/map_'+variables[vv]+'_'+seasons[sea]+'_'+leads[ll]+'_'+scores[sc]+'_'+str(round(critval*100))+'_'+domain+'_'+model_dataset[dd]+'_vs_'+ref_dataset[dd]+'_corr_outlier_'+corr_outlier+'_detrended_'+detrending+'_'+str(file_years[0])+str(file_years[1])+'.'+figformat
                    title = variables[vv]+' '+seasons[sea]+' '+leads[ll]+' '+scores[sc]+' '+str(critval)+' '+domain+' '+model_dataset[dd]+' vs '+ref_dataset[dd]+' '+str(file_years[0])+' '+str(file_years[1])
                    cbarlabel = scores[sc]
                    agreeind = (pval[sea,ll,:,:] < critval) & (rho[sea,ll,:,:] > 0)
                    get_map_lowfreq_var(rho[sea,ll,:,:],xx,yy,agreeind,minvals_map[sc],maxvals_map[sc],dpival,title,savename,halfres,colormap_ascend,titlesize,cbarlabel)

    ##close input nc files and produced xr dataset
    nc_results.close()
    plotme.close()
    print('INFO: plot_seasonal_validation_results.py has been run successfully !')
